---
layout: post
title: Config
date: 2022-03-17T13:53:54.026Z
category: Skynet
lastmod: 2022-03-22T15:16:54.948Z
---

启动 skynet 服务器需要提供一个配置文件，配置文件的编写可以参考 examples/config ，下面是一个简单的配置文件范例:

A config file is needed to start a Skynet server, please refer to examples/config for examples, here is a basic sample:

스카이넷서버를 시작하려면 설정파일이 필요하다. Examples/config 를 참고하자. 여기에 기본샘플이있다.

```lua
root = "./"
thread = 8
logger = nil
harbor = 1
address = "127.0.0.1:2526"
master = "127.0.0.1:2013"
start = "main"	-- main script
bootstrap = "snlua bootstrap"	-- The service for bootstrap
standalone = "0.0.0.0:2013"
luaservice = root.."service/?.lua;"..root.."test/?.lua;"..root.."examples/?.lua"
lualoader = "lualib/loader.lua"
snax = root.."examples/?.lua;"..root.."test/?.lua"
cpath = root.."cservice/?.so"
```
这个配置文件实际上就是一段 lua 代码，通常，我们以 key = value 的形式对配置项赋值。skynet 在启动时，会读取里面必要的配置项，并将暂时用不到的配置项以字符串形式保存在 skynet 内部的 env 表中。这些配置项可以通过 skynet.getenv 获取。

This config file is actually a block of Lua code, usually, we use key = value to set config value. When Skynet gets started, it'll read required config items, and put the config item that's no in use in the env table in string format. These config items can be accessed with skynet.getenv.

이설정파일은 실제로 루아코드이다, 보통 key=value 형식으로 값을 설정한다. 스카이넷이 시작되었을때 필요한 설정항목을 읽을것이다. 그리고 사용하지 않는 설정항목은 env 테이블에 문자열형식으로 넣는다. 이들 설정항목은  skynet.getenv 를 통해 접근할수있다.

必要的配置项有: Required config items:
필요한 설정항목:

* thread 启动多少个工作线程。通常不要将它配置超过你实际拥有的 CPU 核心数。
* thread how many worker threads will be started. It should be less than the number of CPU cores.
* Thread 는 워킹스레드의갯수이다. 일반적으로 CPU 코어갯수보다 작아야한다.

*bootstrap skynet 启动的第一个服务以及其启动参数。默认配置为 snlua bootstrap ，即启动一个名为 bootstrap 的 lua 服务。通常指的是 service/bootstrap.lua 这段代码。

* bootstrap the first service Skynet starts and its starting parameters. The default config is snlua bootstrap, which is a Lua service with the name bootstrap. It's usually about service/bootstrap.lua script.
* Bootstrap  스카이넷이 기동하는 첫번째 서비스이자 그것의 시작하는 파라메터들이다. 기본 설정은 snlua bootstrap 이다. Bootstrap 이란 이름의 루아서비스이다.  보통 service/bootstrap.lua 스크립트를 말한다

* cpath 用 C 编写的服务模块的位置，通常指 cservice 下那些 .so 文件。如果你的系统的动态库不是以 .so 为后缀，需要做相应的修改。这个路径可以配置多项，以 ; 分割。
* cpath the location of the service modules in C, which usually refers to the .so files in cservice folder. If your dynamic-link library isn't using .so postfix, you need to change it. To add multiple path values, separate your values with a ; semi-colon.

* cpath 는 c로 쓰여진 서비스모듈의 위치이다. 보통 cservice폴더아래의 .so 파일을 가르킨다. 만약 당신의 시스템의 동적라이브러리가 .so 확장자가 아니라면 관련된 내용을 변경해야한다. 이 경로는 여러개의항목을 설정할수있으며 ; 로 구분한다

在默认的 `bootstrap` 代码中还会进一步用到一些配置项:

The default bootstrap script also uses the following config items:
기본 bootstrap 스크립트는 또한 다음의 설정항목을 사용한다.

* logger 它决定了 skynet 内建的 `skynet_error` 这个 C API 将信息输出到什么文件中。如果 logger 配置为 nil ，将输出到标准输出。你可以配置一个文件名来将信息记录在特定文件中。
* logger it sets the output path of Skynet internal C API skynet_error. If the logger is set to nil, the output will be stdout. you can specify a filename for logging.
* Logger 는 skynet 내부의 skynet_error 의 출력 내용을 어떤 파일에 넣을것인지 결정한다. 만약 logger 가 nil 로 설정되어있다면 출력은 stdout 이 된다. 당신은 로깅을 위해 특정 파일이름을 넣을수있다.


* logservice 默认为 "logger" ，你可以配置为你定制的 log 服务（比如加上时间戳等更多信息）。可以参考 service_logger.c 来实现它。注:如果你希望用 lua 来编写这个服务，可以在这里填写 snlua ，然后在 logger 配置具体的 lua 服务的名字。在 examples 目录下，有 config.userlog 这个范例可供参考。
* logservice defaults to logger, you can set your own log service (for example log with a timestamp or other info). Please refer to service_logger.c for implementation. Note: if you want to write this service in Luas, you need to set it to snlua and then the Lua service name in logger config. Examples can be found in config.userlog script in the example folder.
* Logservice 의 기본값은 logger 이다. 스스로 제작한 log 서비스를 설정할수있다(예를들어 시간과 다른정보를 포함한 로그). 구현은 service_logger.c 를 참고하기를 바란다. 주: 만약 루아로 로거서비스를작성하고싶으면 snlua 에 추가할수있다 그리고 logger 에 구체적 lua 서비스 이름을 설정한다. Examples 디렉토리아래에 config.userlog 이범례를 참고할수있다.

* logpath 配置一个路径，当你运行时为一个服务打开 log 时，这个服务所有的输入消息都会被记录在这个目录下，文件名为服务地址。
* logpath sets a path, when a service starts and opens log, all input messages of this service will be recorded in this directory, the name of the file is the service address.
* Logpath 한개경로를 설정한다. 운행시 log 를 열었을때, 이 서비스는 모든 출력소시를 이디렉토리에 기록한다. 파일이름은 서비스주소이다.

* standalone 如果把这个 skynet 进程作为主进程启动（skynet 可以由分布在多台机器上的多个进程构成网络），那么需要配置standalone 这一项，表示这个进程是主节点，它需要开启一个控制中心，监听一个端口，让其它节点接入。
* standalone set this item if start this Skynet process as the main process (Skynet can be a network consists of processes from different machines), that means this process is the main node, it needs a control center and a listening port for other nodes to connect.
* Standalone 만약 이항목이 설정되면 skynet 이 시작할때 메인프로세스로 시작한다 (스카이넷은 서로다른 설비들에 네트워크 상의 프로세스들로 이루어질수있다) 이것의 뜻은 이프로세스가 메인노드임을 의미한다. 이것은 컨트롤센터가 필요하고 다른노드들이 접속하기위한 포트를 리스닝해야한다.


* master 指定 skynet 控制中心的地址和端口，如果你配置了 standalone 项，那么这一项通常和 standalone 相同。
* master set the address and port of control center, if the standalone item is set this should be the same as standalone.
* Master 컨트롤센터의 주소와 포트를 설정한다. 만약 standalone 항목이 설정되있다면 이항목은 standalone 과 동일해야한다

* address 当前 skynet 节点的地址和端口，方便其它节点和它组网。注:即使你只使用一个节点，也需要开启控制中心，并额外配置这个节点的地址和端口。
* address the address and port of the current Skynet node, for the convenience of other nodes to form a network. Not: even if you only need one node, you still need to start a control center and set its address and port.
* Address  skynet 노드의 주소와 포트,  다른노드와 네트워크를 편리하게 이루기 위함. 주: 오직한개의 노드만 있더라도 여전히 컨트롤센터를 시작하는데 주소와 포트를 지정해야한다.

* harbor 可以是 1-255 间的任意整数。一个 skynet 网络最多支持 255 个节点。每个节点有必须有一个唯一的编号。
* harbor any int range from 1-255. Skynet network supports 255 nodes at most and each node must have a unique id.
* Harbor 는 1-255 값을 가진다.  스카이넷 네트워크는 최고 255개의 노드를 지원한다 각 노드는 유일한 일련번호를 가져야한다.

* 如果 harbor 为 0 ，skynet 工作在单节点模式下。此时 master 和 address 以及 standalone 都不必设置。
* If harbor is set to 0, Skynet will work as single-node mode, in this case, it's not necessary to set master, address, or standalone item.
* harbor를 0으로 설정하면 skynet 은 싱글노드 모드로 동작한다. 이럴경우, master, address, standalone 항목을 설정할 필요가 없다.


* start 这是 bootstrap 最后一个环节将启动的 lua 服务，也就是你定制的 skynet 节点的主程序。默认为 main ，即启动 main.lua 这个脚本。这个 lua 服务的路径由下面的 luaservice 指定。
* start that's the last step of bootstrap to start Lua service and it's the main function of your defined Skynet node. It defaults to main from main.lua script. the path of this Lua service is defined by luaservice.
* Start   bootstrap 의 마지막순서에 기동하는 Lua 서비스이다. 그리고  당신이 정의한 skynet 노드의 메인함수이다.   기본은 main.lua 스크립트의 main 이다. 이 루아서비스의 경로는 luaservice 에 의해 정의된다.


* enablessl 默认为空。如果需要通过 ltls 模块支持 https ，那么需要设置为 true 。
* enablessl default to nil, set it to true if need ltls module to support HTTPS.
* Enablesssl 기본값은 공백이다. 만약 HTTPS 를 지원하는 TLS 모듈이 필요하다면 true 로 설정한다.

集群服务用到的配置项:
config item used by cluster service:
클러스터서비스에 사용되는 설정항목

* cluster 它决定了集群配置文件的路径。
* cluster tells the path of the cluster config file.
* Cluster 는 클러스터 설정파일의 경로를 알려준다

lua 服务由 snlua 提供，它会查找一些配置项以加载 lua 代码: snlua provides Lua service, it finds the following config items to load Lua script:
Snlua 는 lua 서비스를 제공한다. 다음의 설정항목을 찾아서 Lua 스크립트를 로드한다.

* lualoader 用哪一段 lua 代码加载 lua 服务。通常配置为 lualib/loader.lua ，再由这段代码解析服务名称，进一步加载 lua 代码。snlua 会将下面几个配置项取出，放在初始化好的 lua 虚拟机的全局变量中。具体可参考实现。
* lualoader which Lua script will be used to load Lua service. it's usually set to lualib/loader.lua, then it'll parse the name of services and load Lua scripts. snlua will load the following items and set them to global variables of initialized Lua VM. Please check the code for details.
* lualoader   Lua 스크립트가 lua service 로딩하는데 사용된다. 보통은 lualib/loader.lua 로 설정된다. 그러면 서비스의 이름을 파징하고 lua 스크립트를 로딩한다. Snlua 는 다음의 아이템들을 로딩하고 VM 을 초기화할때 global 변수로 설정한다.  자세한내용은 코드를 체크하라.

* SERVICE_NAME 第一个参数，通常是服务名。
* SERVICE_NAME is the first parameter, it's usually the service name.
* SERVICE_NAME 은 첫번째 파라메터이다. 이것은 보통 서비스이름이다.

* LUA_PATH config 文件中配置的 lua_path 。
* LUA_PATH lua_patch item from config file.
* LUA_PATH  config 파일내의 lua_path 

* LUA_CPATH config 文件中配置的 lua_cpath 。
* LUA_CPATH lua_cpatch item from config file.
* LUA_CPATH  config 문서중설정한 lua_cpath

* LUA_PRELOAD config 文件中配置的 preload 。
* LUA_PRELOAD preload item from config file.
* LUA_PRELOAD config 파일중설정한 preload

* LUA_SERVICE config 文件中配置的 luaservice 。
* LUA_SERVICE luaservice item from config file.
* LUA_SERVICE config 파일중 설정한 luaservice

* luaservice lua 服务代码所在的位置。可以配置多项，以 ; 分割。如果在创建 lua 服务时，以一个目录而不是单个文件提供，最终找到的路径还会被添加到 package.path 中。比如，在编写 lua 服务时，有时候会希望把该服务用到的库也放到同一个目录下。
* luaservice the code path of Lua service. To add multiple path values, separate your values with a semi-colon. If the Lua service is created from a folder, not a single file, the path will be added to package.path. For example, when developing Lua service, you may want to put the libs used by this service in the same folder.
* Luaservice   lua 서비스의 코드패스, 여러개설정할수있으며 ";" 로 구분한다. 만약 루아서비스를 생성할때 파일이아니라 폴더에서 생성한다면, path 는 package.path 로 추가된다,

* lua_path 将添加到 package.path 中的路径，供 require 调用。
* lua_path will be put in package.path for require use.
* Lua_path 는 package.path 안에 넣는다 require 사용을 위해

* lua_cpath 将添加到 package.cpath 中的路径，供 require 调用。
* lua_cpath will be put in package.cpath for require use.
* Lua_cpath  는 package.cpath 에 넣는다 require 사용을 위해

* preload 在设置完 package 中的路径后，加载 lua 服务代码前，loader 会尝试先运行一个 preload 制定的脚本，默认为空。

* preload after setting paths from package and before loading Lua service scripts, the loader will execute a script from preload if it's set and it defaults to nil.
* Preload:  package 의 경로 설정후 luascript 로딩전, 로더는 preload 의 스크립트를 실행한다. 만약에 설정되있다면

* snax 用 snax 框架编写的服务的查找路径。
* snax the path of services written with snax framework.
* snax   snax 프레임워크로 쓰여진 서비스들의 경로

* profile 默认为 true, 可以用来统计每个服务使用了多少 cpu 时间。在 DebugConsole 中可以查看。会对性能造成微弱的影响，设置为 false 可以关闭这个统计。
* profile default to true, it's used to calculate how much CPU time each service uses. Check it in DebugConsole. It affects performance slightly, set to false to disable it.
* profile  기본값은 true 이다, 이것은 각서비스가 사용하는 cpu 시간을 계산하는데 사용된다. 그값은 debug 콘솔에서 확인할수있다. 이것은 퍼포먼스에 약간의 영향을 미친다. False 로 설정하여 비활성화할수있다.


另外，你也可以把一些配置选项配置在环境变量中。比如，你可以把 thread 配置在 SKYNET_THREAD 这个环境变量里。你可以在 config 文件中写:

In addition, you can set config items from environment variables. For example, if you want to set thread item with SKYNET_THREAD environment variable. Set it in the config file as follows:

그외에,  환경변수로부터 설정값을 넣어줄수있다. 예를들어  thread 항목을 SKYNET_THREAD 환경변수로 셋팅할수있다. 셋팅파일에 다음과 같이 설정한다
```
thread = $SKYNET_THREAD
```

这样，在 skynet 启动时，就会用 SKYNET_THREAD 这个环境变量的值替换掉 config 中的 `$SKYNET_THREAD` 了。
With this, when Skynet starts, it will replace thread item with the environment variable of `SKYNET_THREAD`.
이렇게해서 SKYNET 기동시, SKYNET_THREAD 환경변수가  config 의 `$SKYNET_THREAD` 를 대체하게된다.

# 后台模式 Daemon Mode
데몬모드
daemon 配置 daemon = "./skynet.pid" 可以以后台模式启动 skynet 。注意，同时请配置 logger 项输出 log 。
daemon set daemon = "./skynet.pid" to start Skynet in backgroud. Note: please set logger item for logging.

데몬 설정 daemon = "./skynet.pid"  백그라운드로 스카이넷을 시작할수있다. 주의(동시logger 를 설정해서 로깅을 하기바란다"


