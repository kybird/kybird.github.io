---
layout: post
title: APIList
date: 2022-03-17T13:53:54.026Z
category: Skynet
lastmod: 2022-03-17T13:57:09.224Z
---
# APIList

以下列出了所有 skynet 目前提供的 lua 模块的 API 列表，细节待补充：

아래는 Skynet 현재 제공하는 루이 모듈의 모든 API 리스트이다.  상세내용은 보충해야 한다

skynet [LuaAPI](2022-03-17-LuaAPI.markdown)

构建服务需要的 API ：  
서비스구성에 필요한 API:

* register_protocol(class) 在当前服务类注册一类消息的处理机制。
* register_protocol(class) 현재서비스클래스에 일급메시지의 처리 메커니즘 등록
* start(func) 用 func 函数初始化服务，并将消息处理函数注册到 C 层，让该服务可以工作。
* start(func) func 함수로 서비스초기화，그리고 메시지처리함수를 C언어층에 등록，서비스가 동작하도록함
* init(func) 若服务尚未初始化完成，则注册一个函数等服务初始化阶段再执行；若服务已经初始化完成，则立刻运行该函数。
* init(func) 만약서비스가 초기화되지 않았다면, 한개의함수를 등록하여 서비스초기화후 실행하도록함；만약이미 초기화가 완성되었다면，바로 함수를 수행함。
* dispatch(type, func) 为 type 类型的消息设定一个处理函数。
* dispatch(type, func) type 종류의메시지의 처리함수한개를 설정
* getenv(key) 返回当前进程内注册表项的值。
* getenv(key) 현재프로세스내의 등록된 테이블아이템값 리턴
* setenv(key,value) 向当前进程内注册表添加一项(不可以重置已有配置项）。
* setenv(key,value) 향 현재 프로세스내항목을 한개추가함(이미설정된값을 새로설정할수없음)。
* memlimit(bytes) 设定当前服务最多可以使用多少字节的内存，该函数必须先于 start 函数调用。
* memlimit(bytes) 현재서비스가용한 최대 메모리바이트수설정，이함수는필히 start함수실행전에 수행되어야함。

构建框架需要的 API ：  
프레임워크구성에필요한 API:

* newservice(name, ...) 启动一个名为 name 的新服务。
* newservice(name, ...) 이름이 name인 새로운서비스의 기동。
* uniqueservice(name, ...) 启动一个唯一服务，如果服务该服务已经启动，则返回已* 启动的服务地址。
* uniqueservice(name, ...) 하나의유일한서비스기동，만약이미서비스중이라면 이미기동중인 서비스의 주소를 리턴한다。
* queryservice(name) 查询一个由 uniqueservice 启动的唯一服务的地址，若该服务尚未启动则等待。
* queryservice(name) 유일한서비스 기동의 유일한서비스의 주소 조회, 서비스가 미기동이면 기다린다。
* localname(name) 返回同一进程内，用 register 注册的具名服务的地址。
* localname(name) 동일한프로세스내，register 로 등록한 서비스의 주소를 리턴 한다

任务调度和自身控制 API ：  
작업스케쥴러와 자신컨트롤 API

* sleep(time) 让当前的任务等待 time * 0.01s 。
* sleep(time) 현재작업이 time * 0.01s 동안 기다리도록함。
* yield() 让出当前的任务执行流程，使本服务内其它任务有机会执行，随后会继续运行。
* yield() 현작업실행양보，본서버내다른작업에기회를 준다，바로이어서계속실행하다。
* wait() 让出当前的任务执行流程，直到用 wakeup 唤醒它。
* wait()  현재작업프로세스를 기다리게 합니다, wakeup 을사용해서 깨웁니다
* wakeup(co) 唤醒用 wait 或 sleep 处于等待状态的任务。
* wakeup(co) wait 나 sleep 으로 기다리고 있는 작업을 꺠웁니다.
* fork(func, ...) 启动一个新的任务去执行函数 func 。
* fork(func, ...) 함수를 실행하는 프로세스 기동
* timeout(time, func) 设定一个定时触发函数 func ，在 time * 0.01秒后触发。
* timeout(time, func) time * 0.01초 이후 발동하는 함수 func 설정
* starttime() 返回当前进程的启动 UTC 时间（秒）。
* starttime() 현재프로세스의기동시작 UTC 시간(초) 리턴
* now() 返回当前进程启动后经过的时间 (0.01 秒) 。
* now() 현재프로세스의 기동후 지나간시간을 리턴 0.01초
* time() 通过 starttime 和 now 计算出当前 UTC 时间（单位是秒, 精度是ms）。
* time() startTime 과 now 로 계산한 현재 UTC시간 (단위는 초, 정밀도는 ms)。
* address(addr) 将一个服务地址转换为一个可供显示的字符串。
* address(addr) 서비스의 주소를 표시할수있는 문자열로 변환합니다
* self() 返回当前服务的地址。
* self() 현재서버의주소를 반환
* exit() 结束当前服务。
* exit() 현재서버를 종료

状态查询 API:  
상태조회API:

info_func(func) 注册一个查询内部状态的函数，供 debug 协议调用。
info_func(func) 내부상태조회 함수 등록태, debug 프로토콜 호출 제공
stat(what) 查询当前服务的内部状态，what 可以是
stat(what) 현재서버의 내부상태 조회，what 은 될수있다.
endless 是否处于长期占用 cpu 的状态
endless cpu 의 상태가 장기간 점용상태여부
mqlen 尚未处理的消息条数
mqlen 처리되지않은 메시지의 수
message 已处理的消息条数
message 이미처리한 메시지의수
cpu占用总 cpu 时间
cpu점용합 CPU 점용 합계시간占用总 cpu 时间

消息传播 API ：
메시지전파 API ：

call(addr, type, ...) 用 type 类型发送一个消息到 addr ，并等待对方的回应。
call(addr, type, ...)  type 종류를 사용하여 1개의 메시지를 Addr 보낸다，그리고 상대방의 응답을 기다린다。
send(addr, type, ...) 用 type 类型向 addr 发送一个消息。
send(addr, type, ...) 타입종류를 사용하요 addr 1개의 메시지를 발송。
redirect(addr, source, type, ...) 伪装成 source 地址，向 addr 发送一个消息。
redirect(addr, source, type, ...) 보내는주소를 source 로 위장해서서 addr 주소로 1개의 메시지를 보낸다。
ret(msg, sz) 将打包好的消息回应给当前任务的请求源头。
ret(msg, sz) 현재작업요청의 원본에 패킹완료된 메시지를 보낸다
retpack(...) 将消息用 pack 打包，并调用 ret 回应。
retpack(...) pack 을 이용하여 패킹하고，ret 를 호출한다
response([packfunc]) 生成一个回应函数，用于在将来回应当前任务。当消息不使用默认的 lua 类型时，需提供对应的消息打包函数

response([packfunc]) 한 개의 응답함수를 생성한다，현재의 작업의 장래의 요청에 사용한다.。 
현재메시지가 기본의 lua 형식이 아닐경우,  상응하는 메시지 패킹함수가 필요하다

error(msg) 向 log 服务发送一条消息。
error(msg) 로그서버를 향해   log서버가 한 개의 메시지를 전송함
 服务发送一条消息。
서버발송1개메시지

pack(...) 用默认的 lua 类型打包一个消息，返回可供内部调用的指针和长度。
pack(...) 기본의 lua형식으로 1개의 메시지를 패킹함，내부호출용포인터와 길이를 반환한다
packstring(...) 用默认的 lua 类型打包一个消息，返回一个 lua 字符串。
packstring(...) 기본Lua 형식으로 1개의 메시지를 패킹함，lua 스트링을 리턴함。
unpack(msg [, sz]) 将 pack 或 packstring 打包的消息解包，若没有 sz 则 msg 必须为一个 lua 字符串 。
unpack(msg [, sz]) pack 이나 packstring 으로 패킹한메시지를 언패킹함，sz가없으면 msg 는 루아문자열이여야한다。
tostring(msg, sz) 将一个指针和长度定义的消息包转换成一个字符串。
tostring(msg, sz) 한 개의 포인터와 길이로정의된 메시지를 1개의 문자열로 전환한다 

用于某些特殊需要，只有在明确知道其意义再使用的 API ：
특수요구가 있을경우 사용, 오직 명확히 이러한 사항을알고 사용하는 API:
harbor(addr) 查询一个服务地址在哪个节点上。
harbor(addr) 서버주소가 어떠한 노드에 위치하고있는지 조회。

rawsend(addr, type, msg, sz) 用 type 类型向 addr 发送一个打包好的消息。
rawsend(addr, type, msg, sz) type 유형을 사용하여 addr 을 향하여 한 개의 패킹된 메시지를 발송。
rawcall(addr, type, msg, sz) 用 type 类型发送一个已经打包好的消息到 addr ，并等待对方的回应，但不对回应信息解包。
rawcall(addr, type, msg, sz) type 유형을 사용하여 addr 을 향해 한 개의 패킹된 메시지발송, 그리고 상대방의 응답을 기달림, 하지만 응답패킷을 언팩하지 않음

trash(msg, sz) 销毁一个指针和长度定义的消息包。
trash(msg, sz) 한 개의 포인터와, 길이로 정의된 메시지 소각
dispatch_unknown_request(func) 为无法处理的消息类型设定一个处理函数。
dispatch_unknown_request(func) 처리불가능한 메시지종류를 위한 처리함수를 설정。
dispatch_unknown_response(func) 为无法处理的回应消息设定一个处理函数。
dispatch_unknown_response(func) 처리불가능한 응답메시지 처리를 위한 함수 설정。

内部使用或由于兼容目的存在的 API ：
내부사용이나 호환목적으로 존재하는 API

genid() 生成唯一 session 。
genid() 유일한 세션생성
dispatch_message(typeid, msg, sz, session, source) 默认的消息处理过程，由 C 层传递给它消息的五元组：消息类型 id 、指针、长度、session 号、消息源地址。
dispatch_message(typeid, msg, sz, session, source) 기본메시지처리과정 C층에서 메시지로 전달되는 다섯가지내용：메시지유형 id 、포인터、길이、세션번호、메시지주소。

pcall(func, ...) 执行一个函数，捕获可能抛出的异常，并保证在此之前运行由 init 注册的初始化过程。
pcall(func, ...) 함수하나를 실행，익셉션이 발생했을시 잡아내어，운행전 init 시 등록한 초기화 과정이 진행되도록 보장합니다。
init_service(func) 用 func 函数初始化服务。
init_service(func) func 함수를 사용해서 서비스 초기화
endless() 查询当前服务的当前任务是否处于长期占用 cpu 的状态。
endless() 현재서버의현재작업이 CPU를 장기점유상태인지 조회
mqlen() 查询当前服务有多少尚未处理的消息。
mqlen() 현재서비스에 몇 개의 메시지가 미처리인지 조회
task(result) 返回当前服务尚未处理完成的任务调用堆栈信息。
task(result) 현재서비스의 완료되지않은 호출스택정보를리턴
task() 返回尚未处理完成的任务的个数。
task() 처리미완료의 타스크갯수 리턴
task("init") 返回未完成的初始化任务的调用堆栈信息。
task("init") 미완성의 초기화 타스크의 호출스택정보 리턴
task(session) 返回 session 对应的任务的调用堆栈信息。
task(session) session 대응의 타스크의 호출스택정보 리턴
term(source) 假定 source 服务已经退出。
term(source) source 의 서비스가 이미 종료되었다고 가정함
通过导入 skynet.manager 的附加 API ，由于兼容目的或构建框架的目的而存在：
Skynet.manager IMPORT 로 추가된 API ，호환목적과 프레임워크구성을 위해 존재함
launch(name, ...) 直接启动一个 C 服务。
launch(name, ...) C서버를 바로 기동한다。
kill(addr) 强制退出一个服务。
kill(addr) 서버한개를 종료한다
abort() 结束 skynet 进程。
abort() skynet 프로세스 종료
register(name) 给当前服务起一个字符串名。
register(name) 현재서비스에 문자열이름을 부여한다
name(name, address) 为 address 指定的服务起一个名字。
name(name, address) address 로 지정된 서버에 이름을 부여한다。
forward_type(map, start_func) 为当前服务注册一个以消息转发为目的的消息处理函数。
forward_type(map, start_func) 현재서비스에 메시지전달목적의 함수를 등록한다
filter(filter_func, start_func) 为当前服务注册一个消息处理函数，并在每条消息前注册一个消息过滤器。
filter(filter_func, start_func) 현재서비스에메시지처리함수를 등록한다，그리고 모든메시지에 대해 전처리기를 등록한다。
monitor(address) 注册一个全局服务监控服务，监控所有服务的退出事件。
monitor(address) 글로벌서비스모니터서비스를 등록한다，모든서비스의 종료이벤트를 모니터한다
skynet.cluster Cluster



call(node, address, ...) 向一个节点上的一个服务提起一个请求，等待回应。
call(node, address, ...) 특정노드의 특정서비스에 요청을후 응답을 기다린다
send(node, address, ...) 向一个节点上的一个服务推送一条消息。
send(node, address, ...) 특정노드의특정서비스에 메시지를 푸쉬한다。
open(port) 让当前节点监听一个端口。
open(port) 현재노드가 특정포트를 리슨하도록 한다。
reload([config]) 重新加载当前节点的网络配置，可以提供一个 config 表，取代文件配置。
reload([config]) 현재노드의 네트워크설정을 재로드한다，파일설정대신 config 표를 제공할수있다.
proxy(node, address) 为远程节点上的服务创建一个本地代理服务。
proxy(node, address) 원격노드의서비스를위해 로컬프록시 생성。
snax(node, name, address) 向远程节点上的 snax 服务创建一个本地代理。
snax(node, name, address) 원격노드상의 snax 서비스에 로컬프록시 만들기
register(name, address) 在当前节点上为一个服务起一个字符串名字，之后可以用这个名字取代地址。
register(name, address) 현재노드의 서비스에 이름 부여，이후이름으로 주소획득가능
query(node, name) 在远程节点上查询一个名字对应的地址。
query(node, name) 원격노드상에서 이름으로 대응하는 주소조회。
skynet.coroutine Coroutine

用于取代 lua 默认的 coroutine 库，以和 skynet 框架配合。新增 api 有：
Skynet  프레임워크에 맞추기위해 루아기본coroutine 라이브러리대신사용, 새로추가된 API 는 다음과같음:

Use instead lua default 

thread(co) 返回一个 coroutine 所属的 skynet 任务。
thread(co) coroutine 에 속한 skynet 작업을 리턴。

向远程节点上的 snax 服务创建一个本地代理。


Snax service on the Remote node 


skynet.codecache CodeCache

skynet.profile Profile

skynet.datacenter DataCenter

skynet.harbor Cluster

skynet.multicast Multicast

skynet.queue CriticalSection

skynet.sharedata ShareData

skynet.socket Socket

skynet.dns Socket

skynet.socketchannel SocketChannel

待补充：
보충필요：

skynet.db.redis

skynet.db.mongo

skynet.db.mysql

bson

sproto

skynet.crypt

skynet.datasheet

http
