---
layout: post
title: UniqueService
date: 2020-01-02 19:20:23 +0900
category: Skynet
lastmod: 2022-03-17T14:26:54.371Z
---

我们可以通过 skynet.newservice 启动一个 lua 编写的服务。同一段脚本可以启动多份，每个有不同的地址。地址是区分不同服务的唯一标识。
skynet.newservice 를 통해 lua 로 쓰여진 서비스를 기동할 수 있다. 하나의 스크립트를 여러개 기동시킬 수 있으며 모두 서로다른 주소를 가진다. 주소는 서로 다른서비스의 유일한 식별자이다.


但有时，整个系统中解决一类事务只需要一个服务，在系统启动时，它便启动好，而其它服务需要知道它的地址以便于使用它。这个时候，使用 skynet.uniqueservice 是更好的选择。
하지만 가끔, 전체 시스템에서 한종류의 일을 해결하는데 한개의 서비스만 필요하며, 시스템 기동시, 기동이 완료된후, 다른 서비스들은 그 서비스의 주소를 알아야 할 필요가 있을때가 있다.
이럴때, skynet.uniqueueservice 는 좋은 선택이다.


skynet.uniqueservice 和 skynet.newservice 的输入参数相同，都可以以一个脚本名称找到一段 lua 脚本并启动它，返回这个服务的地址。但和 newservice 不同，每个名字的脚本在同一个 skynet 节点只会启动一次。如果已有同名服务启动或启动中，后调用的人获得的是前一次启动的服务的地址。
skynet.uniqueservice 와 skynet.newservice 의 입력 파라메터는 동일하며, 모두 스크립트이름으로 lua 스크립트를 찾아 기동한며, 응답값은 이서비스의 주소이다. 하지만 newservice 의 다른점은, 각각의 이름의 스크립트가 하나의 skynet 노드에서 한번만 실행된다. 만약 이미 같은 이름의 서비스가 기동되었거나 기동중이라면, 나중에 호출된 반환값은 첫번째 기동한 서비스의 주소이다
> 역자: 테스트해볼까
> 

它很大程度上取代了具名服务（不再推荐使用的早期特性）的功能。很多 skynet 库都附带有一个独立服务，你可以在库的初始化时，写上类似的语句：
UniqueService 는  네임서비스(이젠 추천하지 않는 초기의 특성) 의 기능을 대체한다. 많은 skynet 라이브러는 모두 독립적인 서비스를 가지고 있으며, 라이브러리 초기화 할때, 비슷한 코드를 사용할 수 있다.



```lua
local SERVICE
skynet.init(function()
  SERVICE = skynet.uniqueservice "foobar"
end)
```

这个范例会注册一个初始化函数去初始化 SERVICE 变量。而你的库函数就可以使用 SERVICE 这个地址来访问对应的唯一的 foobar 服务了。
이 예제는 초기화 함수를 등록하여 SERVICE 변수를 초기화한다. 라이브러리에서는 SERVICE 주소를 통하여 유일한 foobar 서비스에 접근할 수 있다.



uniqueservice 采用的是惰性初始化的策略。整个系统中第一次调用时，服务才会被启动起来。有时，你并不希望做惰性初始化，而在 skynet 启动脚本里明确把必须的服务初始化好（这个初始化过程可能比较漫长，惰性初始化会导致不必要的运行时延迟）。那么，如果你明确知道服务已经启动好，可以使用 skynet.queryservice 来查询已有服务。如果这个服务不存在，这个 api 会一直阻塞到它启动好为止。
uniqueservice는 지연 초기화전략을 채용하고 있다. 전체 시스템에서 첫번째 호출될때, 서비스는 초기화를 시작한다. 어떤 상황에서는, lazy 초기화를 원하지 않을수 있으며, skynet 기동 스크립트에서 명시적으로 필수적인 서비스를 초기화 할수 있다 (초기화 과정은 비교적 느리고 길수 있다, 지연 초기화는 불필요한 시스템 지연을 피할수 있다).그러면, 어떻게 어떤 서비스가 이미기동 되었는지 알수 있을까, skynet.queryservice 를 통해 이미 존재 하는 서비스를 검색 할수 있따. 만약 이 서비스가 존재하지 않으면, 이 API 는 블럭되어 이서비스가 기동될까지 기다린다.


默认情况下，uniqueservice 是不跨节点的。也就是说，不同节点上调用 uniqueservice 即使服务脚本名相同，服务也会独立启动起来。如果你需要整个网络有唯一的服务，那么可以在调用 uniqueservice 的参数前加一个 true ，表示这是一个全局服务。
기본상황에서, uniqueservice 는 크로스 노드하지 않다. 다시말해서, 서로 다른 노드에서 uniqueuservice 는 같은이름의 서비스가 될수 있으며, 서비스 또한 독립적으로 기동된다. 만약 전체 네트워크에서 유일한 서비스가 필요다면,  uniqueueservice 의 파라메터의 파라메터 앞에 true 를 추가하여, 전역서비스임을 명시한다.



对应的，查询服务 queryservice 也支持第一个参数为 true 的情况。这种全局服务，queryservice 更加有用。往往你需要明确知道一个全局服务部署在哪个节点上，以便于合理的架构。你可以在你设计的节点上的启动脚本中调用 skynet.uniqueservice(true, "foobar") 将服务启动后，然后再在其它使用它的地方调用 skynet.queryservice(true, "foobar") 。
대응하는, 서비스를 검색하는 queryservice 또한 첫번째 파라메터가 true 인 상황을 지원한다. 이런 전역서비스, queryservice 는 매우 요용하다. 늘 전역서비스가 어느노드에 위치해있는지 명확히 알 필요가 있으며, 이는 합리적인 구조이다. 설계한 노드에 기동스크립트에서 skynet.uniqueservice(true, "foobar")로 서비스를 기동후, 다른서비스에서 이서비스의 주소를 skynet.queryservice(true, "foobar") 를 호출하여 사용한다.



和 DataCenter 不同，uniqueservice 是一个专用于服务管理的模块。它在服务地址管理上做了特别的优化。因为对于同一个名字，只允许启动一次，且不准更换。所以，在实现上，我们可以在每个节点缓存查询过的结果，而不必每次都去中心节点查询。
DataCenter 와 다르게, uniqueservice 는 서비스관리전용 모듈이다. 서비스주소관리에 특별한 최적화를 하였다. 서로다른이름에대해, 한개의 기동만을 허용하고, 대체를 허용하지 않는다. 구현에 있어서, 모든 노드에서 검색했던 결과를 캐쉬하여, 매검색마다 중심노드의 검색을 통하지 않도록한다.




